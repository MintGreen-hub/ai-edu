## 11.4 多项式核函数

多项式核
$$K(\boldsymbol{x}_i, \boldsymbol{x}_j)=[\gamma (\boldsymbol{x}_i \cdot \boldsymbol{x}_j) + r]^d \tag{12.4.1}$$


我们先用多项式核函数验证一下 12.1 小节中的一维非线性问题。

关键的函数调用代码如下：

```python
def poly_svc_1(X, Y, d):
    model = SVC(kernel='poly', degree=d)
    model.fit(X,Y)
```

其中 d 表示多项式的次数，如果不指定的话，缺省值为 3。得到的分类结果如图 12.4.2。

<img src="./images/12-4-1.png" />

<center>图 12.4.1 </center>

这是用颜色渐变的方式显示的分类结果，黄色为正类区域，绿色为负类区域。可以看到一个奇怪的现象：degree=2,4,6 时，分类结果是正确的；degree=3,5,7 时，分类结果错误。一个是奇数，一个是偶数。这是为什么呢？

仔细查看 SVC 函数的文档，得知当式 12.4.1 中的 $r$ 不指定时，缺省为 0，具体的参数项名称是 coef0。如果忽略 $\gamma$ 值（在此例中不重要），则式 12.4.1 变为：

$$K(\boldsymbol{x}_i, \boldsymbol{x}_j)=(\boldsymbol{x}_i \cdot \boldsymbol{x}_j)^d, \quad d=2,3,4,5,6,7 \tag{12.4.2}$$

在 12.1 节中，经过试验，确定了式 12.4.3 所示的映射函数是可以完成从线性到非线性的映射的，

$$
f(z)=[z,\ z^2] \tag{12.4.3}
$$

那么下面就可以验证一下当 d=2,3 两种情况时，式 12.4.2 展开为映射函数时，是否与式 12.4.3 一致。注意在本例中是一维特征，所以 $\boldsymbol{x}$ 展开后只有 $x_1$ 项，而不是 $x_1,x_2$ 等等。

- d=2 时

$$
K(\boldsymbol{x}_i, \boldsymbol{x}_j)=(\boldsymbol{x}_i \cdot \boldsymbol{x}_j)^2=(x_{i1} x_{j1})^2=x_{i1}^2 x_{j1}^2
\tag{12.4.4}
$$

所以映射函数是：
$$
\phi(z)=[z^2] 
\tag{12.4.5}
$$

具有 $z^2$ 项特征，对于该问题来说已经足够了，因为原始样本特征值会从 $[-1.5,-1,-0.5,0,0.5,1,1.5]$ 将会变成 $[2.25,1,0.25,0,0.25,1,2.25]$，其中，小于等于 0.25 的样本会被分类为正类，大于等于 1 的样本为负类，具体的分界线值可能是 (0.25,1) 之间的一个数值。

所以 d=2 时可以正确分类。

- d=3 时

$$
K(\boldsymbol{x}_i, \boldsymbol{x}_j)=(\boldsymbol{x}_i \cdot \boldsymbol{x}_j)^3=(x_{i1} x_{j1})^3=x_{i1}^3 x_{j1}^3
\tag{12.4.6}
$$

所以映射函数是：
$$
\phi(z)=[z^3] 
\tag{12.4.7}
$$

根据式 12.4.7，原始样本特征值会从 $[-1.5,-1,-0.5,0,0.5,1,1.5]$ 将会变成 $[-3.375,-1,-0.125,0,0.125,1,3.375]$，读者可以自己在二维坐标系上绘制出这些样本点（横坐标为原始特征值，纵坐标为 $x^3$ 项特征值），实际上就是 $y=x^3$ 的曲线，不是线性可分的。见图 12.4.3。

<img src="./images/12-4-2.png" height='300'/>

图 12.4.2 

所以 d=3 时不能正确分类。



我们是不是忽略了什么细节？

根据式 12.4.1，里面的参数 $r$ 并没有体现出来；仔细看 SVC 函数的文档，会发现有一个 coef0 参数，解释得比较含糊：
```
    coef0 : float, default=0.0
        Independent term in kernel function.
        It is only significant in 'poly' and 'sigmoid'.
```
但是文档里既然说这个参数是很重要（significant），所以不妨试一下。修改代码如下：

```python
def poly_svc(X, Y, d, r):
    model = SVC(kernel='poly', degree=d, coef0=r)
    model.fit(X,Y)
```

在调用时指定 coef0=1，得到如下结果：

<img src="./images/12-4-3.png" />

<center>图 12.4.3 </center>

这一次，无论 degree 是奇数还是偶数，结果都是正确的。正负类各有两个支持向量，分别是 2、4 和 1、5 号样本。

这是为什么呢？

原因还要从式 12.4.1 说起，如果我们令 $\gamma=1, r=1，d=3$ 的话，式 12.4.1 实例化为式 12.4.8（用一维特征做实例化推导）：

$$
\begin{aligned}
K(x_i, x_j)&=[(\boldsymbol{x}_i \cdot \boldsymbol{x}_j)+1]^3
\\\\
&=(\boldsymbol{x}_i \cdot \boldsymbol{x}_j)^3+3(\boldsymbol{x}_i \cdot \boldsymbol{x}_j)^2+3(\boldsymbol{x}_i \cdot \boldsymbol{x}_j)+1
\\\\
&=x_{i1}^3 x_{j1}^3 + 3 x_{i1}^2 x_{j1}^2 + 3 x_{i1} x_{j1} + 1
\end{aligned}
\tag{12.4.8}
$$

则映射函数为：

$$
\phi(z)=[z_1^3,\sqrt{3}z^2, \sqrt{3}z,1] \tag{12.4.9}
$$

可以看到在映射函数中有 $z^2$ 项特征，这个特征已经足够把两类样本分开了。

下面我们来验证一下这个推论是否正确。首先按式 12.4.9 做特征映射：

```python
# 按照式 12.4.9 建立映射函数
def mapping(X_raw):
    # 申请一个7行4列的新特征矩阵
    X_new = np.zeros(shape=(X_raw.shape[0],4))
    # 第0列填入 z^3
    X_new[:,0] = X_raw[:,0] ** 3
    # 第1列填入 sqrt(3) * z^2
    X_new[:,1] = math.sqrt(3) * X_raw[:,0] ** 2
    # 第2列填入 sqrt(3) * z
    X_new[:,2] = math.sqrt(3) * X_raw[:,0]
    # 第3列填入 1
    X_new[:,3] = 1

    return X_new
```
打印出 X_new 的值为：
```
# x^3     x^2    x      1
[[-3.375  3.897 -2.598  1.   ]
 [-1.     1.732 -1.732  1.   ]
 [-0.125  0.433 -0.866  1.   ]
 [ 0.     0.     0.     1.   ]
 [ 0.125  0.433  0.866  1.   ]
 [ 1.     1.732  1.732  1.   ]
 [ 3.375  3.897  2.598  1.   ]]
```
注意 $x^2,x$ 两项都要乘以 $\sqrt{3}$。

然后经过标准化，再输入到 **线性 SVC** 中：

```python
    ss = StandardScaler()
    X = ss.fit_transform(X_new)

    model = SVC(kernel='linear')
    model.fit(X,Y)
```
打印输出训练结果：

```
权重: [[ 0.    -1.732 -0.     0.   ]]
支持向量个数: [2 2]
支持向量索引: [1 5 2 4]
支持向量ay: [[-1. -1.  1.  1.]]
准确率: 1.0
```
- 准确率为 1.0，说明分类正确。
- 支持向量的数量与样本情况与预测的相同。
- 权重，只有 $x^2$ 项特征的权重有值为 -1.732，其它特征项的权重都为 0，说明式 12.4.9 中，只有 $\sqrt{3}z^2$ 有用。


由此我们可以得到一般性的结论：

1. 尽量给与算法更多的特征值；
2. 算法会自动选择有用的特征值；
3. 算法不会被无效的特征干扰。


<img src="./images/12-4-4.png" />

<center>图 12.4.5 </center>

$\gamma$ 缺省取值为特征数的倒数，$d$ 一般取值为 2，常用形式为 

$$K(x_i, x_j)=[\gamma(\boldsymbol{x}_i \cdot \boldsymbol{x}_j)+1]^2$$



